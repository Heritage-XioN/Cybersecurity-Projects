# Simple Vulnerability Scanner

## Overview
Build a Python script that audits installed software versions against known vulnerability databases to identify security risks. This project teaches security assessment techniques, CVE research, package management, and automated vulnerability detection—crucial skills for maintaining secure systems and managing vulnerability risk.

## Step-by-Step Instructions

1. **Integrate CVE database access** by using existing tools and APIs like `pip-audit` for Python packages or connecting to public CVE databases (NVD, CVE Details, etc.). Understand how CVEs (Common Vulnerabilities and Exposures) are identified, scored using CVSS (Common Vulnerability Scoring System), and tracked across different software versions—research how to programmatically query these databases or use existing vulnerability scanning libraries.

2. **Parse system package managers** to enumerate all installed software on the target system. For Linux systems, interact with package managers like `apt`, `yum`, or `pacman` using subprocess calls to list installed packages and their versions. For Python environments, use `pip list` or inspect the pip directory structure to enumerate dependencies with their exact version numbers.

3. **Create a local vulnerability database** or mapping that lists common software packages and their known vulnerable versions. This can start as a simple JSON file or Python dictionary that maps package names to CVE records and affected version ranges—this gives you flexibility to customize the scanner and update it independently of external APIs.

4. **Implement version comparison logic** that determines whether an installed package version falls within a vulnerable range specified in your database. Handle version number complexities like semantic versioning (1.2.3), pre-release versions, and version ranges—use libraries like `packaging.version` to reliably compare version numbers.

5. **Flag vulnerable packages and calculate risk scores** by creating output that clearly identifies which packages are vulnerable, which CVEs affect them, and the CVSS severity score for each vulnerability. Organize findings by severity (critical, high, medium, low) to help users prioritize remediation efforts on the most dangerous vulnerabilities first.

6. **Suggest remediation actions** including available updates, security patches, or replacement packages when vulnerabilities are found. Provide actionable commands users can run to update vulnerable packages to patched versions, and note when no patch is available yet or when major version upgrades are required.

7. **Generate comprehensive reports** in multiple formats (plain text, JSON, CSV) that document all findings, vulnerability details, severity scores, affected systems, and remediation recommendations. Include metadata like scan date, system information, and total vulnerability counts to make reports suitable for executive review or compliance documentation.

8. **Create automated scanning workflows** that can run on a schedule (via cron or task scheduler) to periodically check systems for new vulnerabilities. Implement notification systems (email alerts, Slack messages, webhook calls) to notify administrators when critical vulnerabilities are discovered, enabling rapid response to emerging threats.

## Key Concepts to Learn
- CVE research and vulnerability databases
- System package management and enumeration
- Version comparison and semantic versioning
- CVSS scoring and risk assessment
- Automated security scanning and reporting

## Deliverables
- Functional vulnerability scanner for installed packages
- Local CVE database with common vulnerabilities
- Risk scoring and severity classification
- Multi-format reporting capabilities
- Remediation recommendations and update guidance
