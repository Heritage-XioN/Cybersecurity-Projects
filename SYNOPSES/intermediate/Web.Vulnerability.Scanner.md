# Web Application Vulnerability Scanner

## Overview
Build an asynchronous web vulnerability scanner that crawls websites and tests for common flaws including XSS (Cross-Site Scripting), SQLi (SQL Injection), and CSRF (Cross-Site Request Forgery) using a modular plugin architecture. This project teaches web security testing, application penetration testing, and demonstrates automated vulnerability detection techniques.

## Step-by-Step Instructions

1. **Understand common web vulnerabilities** by studying OWASP Top 10: XSS allows injecting malicious scripts executing in victim browsers, SQLi exploits unsanitized SQL queries to access/manipulate databases, CSRF tricks users into performing unintended actions on authenticated sites. Learn testing methodologies for each: XSS testing requires injecting payloads and checking for reflection without encoding, SQLi testing involves database error detection and time-based blind SQLi, CSRF requires identifying state-changing requests lacking token validation. Research existing web scanners (Burp Suite, OWASP ZAP) to understand industry approaches.

2. **Implement asynchronous web crawling** using `httpx` and `asyncio` to efficiently discover all accessible URLs on target website. Build a crawler that respects robots.txt, avoids infinitely deep crawling, deduplicates URLs, and stores discovered paths in a database. Extract links from HTML pages, follow redirects appropriately, and build a site map representing all discovered endpoints available for testing.

3. **Design a plugin architecture** for vulnerability tests where each test is implemented as a separate module with standardized interface: plugins receive a URL/request and return findings. Create base plugin classes providing common functionality (sending requests, parsing responses, detecting vulnerabilities), then implement concrete plugins for specific vulnerability types. This modularity allows easy addition of new tests without modifying core scanner logic.

4. **Build XSS detection module** that injects test payloads (simple tags like `<script>alert(1)</script>`, event handlers, etc.) into GET/POST parameters and headers, then analyzes responses for reflection without encoding. Implement both reflected XSS detection (payload echoed in response) and check for stored XSS by analyzing form submissions. Use browser automation tools if needed for JavaScript-based XSS, but start with static analysis.

5. **Implement SQLi detection module** that injects SQL syntax characters and common payloads (single quotes, UNION queries, time delays) into parameters, analyzing responses for SQL errors or suspicious behavior. Implement multiple SQLi detection techniques: error-based (look for SQL error messages), blind time-based (inject delays and measure response time), and UNION-based (inject UNION statements and detect data extraction). Build payloads that work across different database systems (MySQL, PostgreSQL, MSSQL, Oracle).

6. **Create CSRF detection module** that identifies state-changing requests (POST, PUT, DELETE operations) lacking proper CSRF tokens. Check whether requests include CSRF tokens in hidden form fields or request headers, verify tokens are validated server-side (test by resubmitting with modified/missing tokens), and flag endpoints without protection. Analyze token generation patterns looking for predictable or missing randomization.

7. **Build result aggregation, severity scoring, and reporting** that collects findings from all plugins, deduplicates results, assigns severity levels based on vulnerability type and exploitability, and generates comprehensive reports. Create HTML/PDF reports showing vulnerabilities, affected endpoints, proof-of-concept demonstrations, and remediation recommendations. Include detailed evidence for each finding allowing developers to understand and fix issues.

8. **Build comprehensive documentation** explaining web security testing concepts, providing scanner usage examples, and discussing automated testing limitations (some vulnerabilities require human analysis, false positives are possible). Compare your scanner to commercial tools and discuss advantages of building custom scanners for specific applications. Include ethical guidelines emphasizing that vulnerability scanning requires authorization, provide responsible disclosure guidance for found vulnerabilities, and explain how automated scanning fits into broader application security programs.

## Key Concepts to Learn
- Web vulnerability types (XSS, SQLi, CSRF)
- Asynchronous HTTP requests and crawling
- Plugin architecture and modularity
- Payload generation and injection techniques
- Response analysis and vulnerability detection
- Severity scoring and reporting
- Ethical web security testing

## Deliverables
- Asynchronous web crawler with deduplication
- Modular plugin-based testing architecture
- XSS detection (reflected and stored)
- SQLi detection (error-based, blind, UNION)
- CSRF detection and validation checking
- Result aggregation and severity scoring
- HTML/PDF reporting with remediation advice
